[TOC]

# Java 基础

## 1、HashMap

### 1.1、`HashMap` 底层原理

HashMap是Java中一种常用的集合类，它是基于哈希表（Hash Table）实现的，可以用来存储键值对（key-value）。

下面是HashMap实现原理的简单概述：

- 1、内部实现：HashMap内部使用数组来保存键值对，数组中的每个元素都是一个链表，链表中保存了具有相同哈希码的键值对。当数组中元素较多时，为了提高查找效率，链表会转化为红黑树，以减少查找的时间复杂度。
- 2、计算哈希码：在向HashMap中添加一个键值对时，会根据键的哈希码来确定该键值对的存储位置。HashMap通过调用键的hashCode()方法来计算哈希码。
- 3、处理哈希冲突：由于哈希码是有限的，因此在向HashMap中添加键值对时，可能会发生哈希冲突（即不同的键哈希码相同）。为了处理哈希冲突，HashMap会将具有相同哈希码的键值对存储在同一个链表中，当链表中的元素较多时，会将链表转化为红黑树。
- 4、扩容机制：当HashMap中的元素达到一定阈值时，HashMap会进行自动扩容。扩容会重新计算每个键值对的哈希码，并将他们存储在新的更大的数组中。扩容会导致HashMap中的所有键值对的存储位置发生变化，因此需要重新计算和存储每个键值对的哈希码。
- 5、并发处理：在多线程环境下，HashMap不是线程安全的。为了解决这个问题，Java提供了ConcurrentHashMap类来解决并发问题。


HashMap是一种高效的键值对存储结构，它基于哈希表实现，可以在常数时间内完成添加、删除和查找操作，但在处理哈希冲突时，需要使用链表和红黑树来保证性能。

### 1.2、`HashMap` 是怎样通过 `key` 获取到值的

* 在HashMap中，每个元素都是通过键值对（key-value）的形式存储的，其中键是用于查找值的索引，当需要查找某个键对应的值时，HashMap会根据键的哈希值（通过调用key的hashCode方法得到）和容量计算出对应桶的位置，然后在该桶中查找对应的键值对。
* 当桶中只有一个元素时，直接返回该元素的值即可。如果桶中有多个元素，HashMap会先根据键的哈希值和桶中元素的哈希值比较，找到哈希值相同的元素，然后在调用键的equals方法比较键是否相等。如果键相等，则返回对应的值；否则继续在链表或红黑树中查找，直到找到对应的键值对或查找结束。
* 由于HashMap使用哈希表存储元素，因此在查找时具有非常高的效率，理论上可以实现O（1）的时间复杂度。但是在实际使用中，由于哈希冲突等因素的影响，可能会出现查找效率下降的情况，因此在使用HashMap时，应该注意键的哈希值的均匀分布、负载因子的设置等原因，以优化HashMap的性能。

### 1.3、`HashMap` 和 `HashTable` 区别

HashMap和HashTable是两个常用的Java集合框架中的映射类型容器，他们的区别如下：

* 1、线程安全性：HashTable是线程安全的，而HashMap不是。HashTable中的方法都是同步的（synchronized），即他们在多线程访问时会自动获取锁，因此HashTable可以在多线程中安全的使用。而HashMap是非线程安全的，如果在多线程环境中同时对HashMap进行修改操作，可能会导致数据的不一致性和线程安全问题。
* 2、null值：HashTable不行允许键或者值为null，而HashMap允许。在HashTable中，如果试图将null做为键或者值放入其中，将会抛出NullPointerException异常；而在HashMap中，null可以作为键或值存储。
* 3、效率：由于HashTable中的方法都是同步的，因此在多线程环境下会存在一定得性能开销。而HashMap不是同步的，因此在单线程环境中具有较高的效率。
* 4、迭代器：HashTable的迭代器（Enumeration）不支持fail-fast机制，而HashMap的迭代器（Iterator支持）。
* 5、存储顺序：HashMap不保证元素的存储顺序，而HashTable是按照元素插入的顺序进行存储。

综上所述，HashTable在线程安全方面具有优势，但在效率和灵活性方面不如HashMap。因此，在单线程环境下，推荐使用HashMap，而在多线程环境下，可以选择适用HashTable或者ConcurrentHashMap等线程安全的集合框架。

### 1.4、HashMap 与 LinkedHashMap排序问题

HashMap是无序的，LinkedHashMap是有序的，这里的有序是元素的插入顺序。

如果需要进行排序，可以把每个键值对集合都放入到list集合中，然后用Collections.sort()方法进行排序

## 2、Java反射

一句话概括：Java反射是指在运行时获取类的信息，并动态的操作类或对象的机制。

Java反射指的是在运行时获取类的信息，并且可以动态地操作类或者对象。Java反射机制主要包括三个类：Class、Constructor和Method

* 1、Class类：在Java程序运行时，每个类都会有一个对应的class对象，通过class类可以获取类的信息，例如类的名称、接口、属性和方法。
* 2、Constructor类：Constructor类标识类的构造方法，可以通过反射机制创建类的对象。
* 3、Method类：Method类标识类的方法，可以通过反射机制调用类的方法。

## 3、Java序列化

Java序列化是指将一个Java对象流转化为二进制格式的数据流，以便将其存储到文件中或用于网络传输。在Java中通过实现Serializable接口来使一个类来支持序列化。Java序列化可以实现数据的持久化，分布式对象传输等功能。

Java序列化的过程是将Java对象转化为一组字节流，这个过程成为序列化，反之称为反序列化。Java中提供了两种序列化方式：基于对象的序列化`（ObjectOutputStream/ObjectInputStream）`和基于字节流的序列化`（ByteArrayOutputStream/ByteArrayInputStream）`。基于对象的序列化是将整个对象序列化到流中，而基于字节流的序列化是将对象的某些属性序列化到流中。

Java序列化的应用场景包括：

* 1、数据持久化：将Java对象序列化到文件中，实现数据的持久化存储。
* 2、分布式应用：通过网络传输序列化后的对象，实现分布式应用中的对象传输。
* 3、缓存机制：将Java对象序列化到缓存中，以提高应用程序的性能。

需要注意的是，Java序列化不是一种高效的数据传输方式，因为序列化后的数据量较大，序列化和反序列化也会消耗一定的时间。因此在对一些性能要求较高的场景下，可以考虑使用其它更加高效的数据传输方式，比如JSON、Protobuf等。

## 4、temp



## 5、线程

### 5.1、线程的几种状态、算法

Java中的线程共有6中状态，分别是：

* 1、NEW（新建）：当线程对象被创建时，它处于新建状态，此时它并未开始运行。
* 2、Runnable（就绪）：当调用start()方法后，线程进入就绪状态，它处于等待CPU调度执行的状态。线程在此状态下可能正在运行，也可能正在等待CPU分配时间片来运行。
* 3、Running（运行）：当就绪的线程被调度并获得CPU资源时，便进入运行状态。
* 4、Blocked（阻塞）：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态。
* 5、Terminated（销毁）：线程正常结束，

### 5.2、Java 线程池使用 线程池参数

### 5.3、ThreadLocal

ThreadLocal主要解决多线程情况下变量的访问冲突问题，可以将同一个变量在不同的线程中进行隔离，保证每个线程只能访问到自己的变量副本，从而避免了竞争和冲突。

下面是一些使用ThreadLocal的场景：

* 1、数据库连接管理：在使用连接池时，可以将连接对象存放到ThreadLocal中，以保证同一线程中的多次数据库操作都是用同一个数据库连接。
* 2、身份验证信息传递：在web应用中，用户的身份验证信息通常会在一个请求中进行传递，可以将身份验证信息存放在ThreadLocal中，在后续处理请求的各个组件中直接获取。
* 3、全局变量访问：在多线程环境下，全局变量可能被多个线程同时访问，可以使用ThreadLocal将其变成线程本地变量，每个线程只能访问到自己的副本，避免了竞争和冲突。
* 4、线程上下文传递：在某些场景下，需要在线程间传递一些上下文信息，例如请求标识、语言环境等，可以使用ThreadLocal将这些信息存放在线程本地，避免了在方法参数中传递这些上下文信息的繁琐和混乱。

总之，当需要在线程间隔离变量的值，并且这些变量是可变的时，可以考虑使用ThreadLocal。但是需要注意ThreadLocal的使用要合理，避免滥用，否则可能会带来意想不到的后果。

## 6、`Java volatile` 原理

Java中的volatile关键字是一种轻量级的同步机制，主要用于保证多线程之间的可见性和禁止指令重排优化。volatile变量具有以下特性：

* 1、可见性：一个线程对volatile变量的修改，对其他线程是可见的，即读取到的值一定是最新的值，而且所有的线程都会读取到同一个值。
* 2、禁止指令重排：JVM为了提高指令执行效率，可能会对指令进行重排，如果不使用volatile关键字来修饰变量，则重排后的指令可能会影响程序的正确性。volatile关键字可以禁止JVM对指令进行重排，保证指令执行的正确性。

需要注意的是，volatile关键字不能保证原子性，也就是说，多个线程同事修改同一个volatile变量时，可能会产生竞争问题，需要使用synchronized关键字或者Lock接口进行同步控制。

## 7、temp

## 8、设计原则

7大原则，各种原则的侧重点不同：

| 设计原则      | 一句话概括                                                   | 目的                                       |
| ------------- | ------------------------------------------------------------ | ------------------------------------------ |
| ①开闭原则     | 对扩展开放，对修改关闭                                       | 降低维护带来的新风险                       |
| ②依赖倒置原则 | 高层不应该依赖底层，要面向接口编程                           | 更利于代码结构的升级扩展                   |
| ③单一职责原则 | 一个类只干一件事，实现类要单一                               | 便于理解，提高代码的可读性                 |
| ④接口隔离原则 | 一个接口只干一件事，接口要精简单一                           | 功能接口，高内聚低耦合                     |
| ⑤迪米特法则   | 不该知道的不要知道，一个类应该保持对其它对象最少的了解，降低耦合度 | 只和朋友交流，不和陌生人说话，减少代码臃肿 |
| ⑥里氏替换原则 | 不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义 | 防止继承泛滥                               |
| ⑦合成复用原则 | 尽量使用组合或者聚合关系实现代码复用，少使用继承             | 降低代码耦合                               |

实际上，这些原则的目的只有一个：降低对象之间的耦合，增加程序的可复用性、可扩展性和可维护性。

``` html
巧记：一接单，开地里
（情景记忆：骑手一接单，就开到了地里，谐音记忆）
```



## 9、设计模式

一共23种设计模式，分为3大类：

***1、创建型 5种***

巧记：建原抽工单

（情景记忆：一个叫 ***建原*** 的人 ***抽*** 走了 ***工单*** ）

* 建：建造者模式
* 原：原型模式
* 抽：抽象工厂
* 工：工厂方法
* 单：单例模式

***2、结构型模式 7种***

巧记：桥代理组合适配器，享元回家装饰外观

（情景记忆：姓 ***乔*** 的 ***代理组合*** 了一个 ***适配器*** ，***享元*** 同学把带回家 ***装饰*** 它的 ***外观*** ）

* 乔：桥接模式
* 代理：代理模式
* 组合：组合模式
* 适配器：适配器模式
* 享元：享元模式
* 装饰：装饰器模式
* 外观：外观模式

***3、行为型模式 11种***

巧记：访问者写好策略备忘录，观察模板迭代状态，命令中介解释责任链

（情景巧记：在房产中介处，一个访问者写好了购房策略的备忘录，观察了下所用模板的迭代状态，之后命令中介解释下出问题后的责任）

* 访问者：访问者模式
* 策略：策略模式
* 备忘录：备忘录模式
* 观察：观察者模式
* 模板：模板模式
* 迭代：迭代器模式
* 命令：命令模式
* 中介：中介者模式
* 解释：解释器模式
* 责任：责任链模式

## 10、锁

## 11、List

### 11.1、List求交集

## 12、JVM

### 12.1、JVM内存模型

JVM内存模型是指Java虚拟机运行时所管理的内存结构，用于存放Java程序运行时所需要的各种数据。JVM内存模型一般被分为以下几部分：

* 1、堆：

  堆是Java虚拟机管理的最大的内存区域，用于存储对象实例以及数组等数据。堆是所有线程共享的，在JVM启动时即被创建，并被划分为新生代和老年代两个区域。

* 2、本地方法栈：

  本地方法栈，与Java虚拟机栈类似，不同的是本地方法栈用于存储本地方法的信息。

* 3、方法区：

  方法区是Java虚拟机中用于存储已加载的类信息、常量、静态变量、即时编译器编译后的代码等数据的内存区域。在JVM启动时即被创建，是所有线程共享的。

* 4、程序计数器：

  程序计数器是一块较小的内存区域，他可以看做是当前线程所执行的字节码的型号指示器。每个线程都有自己独立的程序计数器，以便在线程切换后能够恢复到正确的执行位置。

* 5、Java虚拟机栈：

  Java虚拟机栈是线程私有的内存区域，用于存储线程执行方法时的局部变量、操作数栈动态链接、方法出口等信息。每个方法在执行时都会创建一个栈帧用于存储这些信息，栈帧在方法执行结束后会被弹出。

### 12.2、JVM内存优化

12.3、`gc` 回收机制、算法

垃圾回收`（Garbage Collection, GC）`是指一种自动的内存管理技术，通过扫描内存中的对象，回收已经不在被使用的对象所占据的内存空间，使得应用程序能够动态地使用可用的内存。GC是JVM的核心部分之一，负责Java应用程序运行时的内存分配、回收和整理：

GC回收机制包括一下几个步骤：

* 1、标记（Marking）
* 2、垃圾清理（Sweeping）
* 3、压缩（Compacting）

常见的垃圾回收算法包括：

* 1、标记-清除算法（Mark-Sweep）
* 2、标记-整理算法（Mark-Compact）
* 3、复制算法（Copying）
* 4、分代收集算法（Generational）



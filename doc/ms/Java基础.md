[TOC]

# Java 基础

## 1、HashMap

### 1.1、`HashMap` 底层原理

HashMap是Java中一种常用的集合类，它是基于哈希表（Hash Table）实现的，可以用来存储键值对（key-value）。

下面是HashMap实现原理的简单概述：

- 1、内部实现：HashMap内部使用数组来保存键值对，数组中的每个元素都是一个链表，链表中保存了具有相同哈希码的键值对。当数组中元素较多时，为了提高查找效率，链表会转化为红黑树，以减少查找的时间复杂度。
- 2、计算哈希码：在向HashMap中添加一个键值对时，会根据键的哈希码来确定该键值对的存储位置。HashMap通过调用键的hashCode()方法来计算哈希码。
- 3、处理哈希冲突：由于哈希码是有限的，因此在向HashMap中添加键值对时，可能会发生哈希冲突（即不同的键哈希码相同）。为了处理哈希冲突，HashMap会将具有相同哈希码的键值对存储在同一个链表中，当链表中的元素较多时，会将链表转化为红黑树。
- 4、扩容机制：当HashMap中的元素达到一定阈值时，HashMap会进行自动扩容。扩容会重新计算每个键值对的哈希码，并将他们存储在新的更大的数组中。扩容会导致HashMap中的所有键值对的存储位置发生变化，因此需要重新计算和存储每个键值对的哈希码。
- 5、并发处理：在多线程环境下，HashMap不是线程安全的。为了解决这个问题，Java提供了ConcurrentHashMap类来解决并发问题。


HashMap是一种高效的键值对存储结构，它基于哈希表实现，可以在常数时间内完成添加、删除和查找操作，但在处理哈希冲突时，需要使用链表和红黑树来保证性能。

### 1.2、`HashMap` 是怎样通过 `key` 获取到值的

* 在HashMap中，每个元素都是通过键值对（key-value）的形式存储的，其中键是用于查找值的索引，当需要查找某个键对应的值时，HashMap会根据键的哈希值（通过调用key的hashCode方法得到）和容量计算出对应桶的位置，然后在该桶中查找对应的键值对。
* 当桶中只有一个元素时，直接返回该元素的值即可。如果桶中有多个元素，HashMap会先根据键的哈希值和桶中元素的哈希值比较，找到哈希值相同的元素，然后在调用键的equals方法比较键是否相等。如果键相等，则返回对应的值；否则继续在链表或红黑树中查找，直到找到对应的键值对或查找结束。
* 由于HashMap使用哈希表存储元素，因此在查找时具有非常高的效率，理论上可以实现O（1）的时间复杂度。但是在实际使用中，由于哈希冲突等因素的影响，可能会出现查找效率下降的情况，因此在使用HashMap时，应该注意键的哈希值的均匀分布、负载因子的设置等原因，以优化HashMap的性能。

### 1.3、`HashMap` 和 `HashTable` 区别

HashMap和HashTable是两个常用的Java集合框架中的映射类型容器，他们的区别如下：

* 1、线程安全性：HashTable是线程安全的，而HashMap不是。HashTable中的方法都是同步的（synchronized），即他们在多线程访问时会自动获取锁，因此HashTable可以在多线程中安全的使用。而HashMap是非线程安全的，如果在多线程环境中同时对HashMap进行修改操作，可能会导致数据的不一致性和线程安全问题。
* 2、null值：HashTable不行允许键或者值为null，而HashMap允许。在HashTable中，如果试图将null做为键或者值放入其中，将会抛出NullPointerException异常；而在HashMap中，null可以作为键或值存储。
* 3、效率：由于HashTable中的方法都是同步的，因此在多线程环境下会存在一定得性能开销。而HashMap不是同步的，因此在单线程环境中具有较高的效率。
* 4、迭代器：HashTable的迭代器（Enumeration）不支持fail-fast机制，而HashMap的迭代器（Iterator支持）。
* 5、存储顺序：HashMap不保证元素的存储顺序，而HashTable是按照元素插入的顺序进行存储。

综上所述，HashTable在线程安全方面具有优势，但在效率和灵活性方面不如HashMap。因此，在单线程环境下，推荐使用HashMap，而在多线程环境下，可以选择适用HashTable或者ConcurrentHashMap等线程安全的集合框架。

### 1.4、HashMap 与 LinkedHashMap排序问题

HashMap是无序的，LinkedHashMap是有序的，这里的有序是元素的插入顺序。

如果需要进行排序，可以把每个键值对集合都放入到list集合中，然后用Collections.sort()方法进行排序

## 2、Java反射

一句话概括：Java反射是指在运行时获取类的信息，并动态的操作类或对象的机制。

Java反射指的是在运行时获取类的信息，并且可以动态地操作类或者对象。Java反射机制主要包括三个类：Class、Constructor和Method

* 1、Class类：在Java程序运行时，每个类都会有一个对应的class对象，通过class类可以获取类的信息，例如类的名称、接口、属性和方法。
* 2、Constructor类：Constructor类标识类的构造方法，可以通过反射机制创建类的对象。
* 3、Method类：Method类标识类的方法，可以通过反射机制调用类的方法。

## 3、Java序列化

Java序列化是指将一个Java对象流转化为二进制格式的数据流，以便将其存储到文件中或用于网络传输。在Java中通过实现Serializable接口来使一个类来支持序列化。Java序列化可以实现数据的持久化，分布式对象传输等功能。

Java序列化的过程是将Java对象转化为一组字节流，这个过程成为序列化，反之称为反序列化。Java中提供了两种序列化方式：基于对象的序列化`（ObjectOutputStream/ObjectInputStream）`和基于字节流的序列化`（ByteArrayOutputStream/ByteArrayInputStream）`。基于对象的序列化是将整个对象序列化到流中，而基于字节流的序列化是将对象的某些属性序列化到流中。

Java序列化的应用场景包括：

* 1、数据持久化：将Java对象序列化到文件中，实现数据的持久化存储。
* 2、分布式应用：通过网络传输序列化后的对象，实现分布式应用中的对象传输。
* 3、缓存机制：将Java对象序列化到缓存中，以提高应用程序的性能。

需要注意的是，Java序列化不是一种高效的数据传输方式，因为序列化后的数据量较大，序列化和反序列化也会消耗一定的时间。因此在对一些性能要求较高的场景下，可以考虑使用其它更加高效的数据传输方式，比如JSON、Protobuf等。

## 4、`gc` 回收机制、算法



## 5、线程

### 5.1、线程的几种状态、算法

### 5.2、Java 线程池使用

### 5.3、ThreadLocal



## 6、`Java volatile` 原理



## 7、JVM内存模型

## 8、设计原则

7大原则，各种原则的侧重点不同：

| 设计原则      | 一句话概括                                                   | 目的                                       |
| ------------- | ------------------------------------------------------------ | ------------------------------------------ |
| ①开闭原则     | 对扩展开放，对修改关闭                                       | 降低维护带来的新风险                       |
| ②依赖倒置原则 | 高层不应该依赖底层，要面向接口编程                           | 更利于代码结构的升级扩展                   |
| ③单一职责原则 | 一个类只干一件事，实现类要单一                               | 便于理解，提高代码的可读性                 |
| ④接口隔离原则 | 一个接口只干一件事，接口要精简单一                           | 功能接口，高内聚低耦合                     |
| ⑤迪米特法则   | 不该知道的不要知道，一个类应该保持对其它对象最少的了解，降低耦合度 | 只和朋友交流，不和陌生人说话，减少代码臃肿 |
| ⑥里氏替换原则 | 不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义 | 防止继承泛滥                               |
| ⑦合成复用原则 | 尽量使用组合或者聚合关系实现代码复用，少使用继承             | 降低代码耦合                               |

实际上，这些原则的目的只有一个：降低对象之间的耦合，增加程序的可复用性、可扩展性和可维护性。

``` html
巧记：一接单，开地里
（情景记忆：骑手一接单，就开到了地里，谐音记忆）
```




## 9、设计模式

## 10、锁

## 11、List

### 11.1、List求交集




